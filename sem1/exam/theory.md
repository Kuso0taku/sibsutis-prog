### 1. Язык Си. Структура программы на языке Си. Этапы компиляции. Препроцессор. Директивы препроцессора. Примеры.
- Язык Си - компилируемый язык программирования низкого уровня (не такого как ассемблер, но с возможностью управления памятью напрямую) со строгой статической типизацией.  
- Структура программы: импорт библиотек, задание макросов, констант, функции, точка входа - main().  
- Этапы компиляции:  
1. Препроцессор - обработка директив (констант, макросов, условной компиляции) - того, что начинается на '#' (define, ifdef, endif, include, ...)  
`$gcc main.c -E main.i`  
2. Компиляция - преобразование кода в ассемблер.  
`$gcc main.i -S main.s`  
3. Линковка (компановка) - сбор всех объектных файлов, ссылок (например, на внешние библиотеки) в один исполняемый файл.  
`$gcc main.s -o main`  

### 2. Переменные и константы. Идентификаторы. Операция присваивания. sizeof и size_t. Квалификатор const. Перечисления. Примеры.  
- Переменные - это именованные области в памяти, контент которых можно изменять.  
- Константы - те же переменные, но без возможности изменения.  
`const PI = 3.14;`
- Литералы тоже являются константами. Литералы - это неименованные области памяти, содержащие какую-то информацию.  
`printf("Hello, world!\n");`, где строка внутри printf - литерал.
- Идентификаторы - уникальные имена переменных.  
- Операция присваивания - присваивает переменной, которая находится слева от знака равно, значение, находящиеся справа. Работает справа налево.
- sizeof - унарный оператор, возвращающий размер типа данных в байтах. Тип возвращаемого значения - size_t.  
`sizeof char;`, результат будет равен 1, т.к. char имеет размер в 1 байт.
- size_t - специальный беззнаковый целочисленный тип данных для хранения размера. По своей сути эквивалентен unsigned int. 
- Квалификатор const - задает константу, т.е "говорит" переменной, что ее теперь нельзя изменять.  
- Перечисления - могут быть заданы с помощью специального типа данных - enum. Счет констант внутри идет от 0. Можно самостоятельно задавать **целочпсленное** значение для константы.  
```
enum Day {
    monday,
    tuesday,
    friday=5,
    SATARDAY,
    SUNDAY,
};
```  

### 3. Базовые типы данных языка Си. Арифметические операторы. Примеры.  
- Базовые типы данных языка Си: целочисленные (char=1byte, short=2, int={2,4}, long={4,8}, long long = 8), вещественные (float=4, double=8, long double = {8,10,12,16}), все они могут быть, как signed, так и unsigned.  
- Целочисленные хранятся в памяти как: 1бит=знак (1="-", 0="+"), остальные биты под чило.
- Вещественные хранятся как: 1бит=знак, порядок (float=8bit, double=11, long double = 15), мантисса=size-порядок-знак.  
- Overflow: для знаковых при переполнении знак меняется на противоположный, для беззнаковых - число обнуляется.  
- Underflow: если в меньшую сторону (для знаковых), то -inf, если в большую, то inf.  
- Арифметические операторы: бинарные (+, -, *, /, %), унарные (+, -, ++, --).  

### 4. Целые числа и числа с плавающей точкой. Машинное представление чисел. Примеры.  
- Все то же самое, что и выше.  

### 5. Символы и символьные строки. Ввод и вывод информации. Символьный и форматированный ввод-вывод. Примеры.  
- Символы - целые числа, являющиеся кодами в таблице ASCII (для широких символов - таблицы UTF-8, UTF-16, ...).  
`char ch = 'A'`  
- Строки - массивы символов, оканчивающиеся специальным символом '\0'.  
`char string[25] = "Hello, world!";`  
- Ввод и вывод производятся через потоки ввода и вывода (stdin и stdout).  
- Стандартные фукнции ввода: scanf, getchar, fgetchar, fgets, gets.  
- Вывода: printf, puts, fputs, fprintf, putchar, fputchar.  
- Символьный ввод-вывод: посимвольная обработка ввода (getchar, fgetchar, putchar, fputchar).  
- Форматированный: возможность вставки какого-то контанта в "строку" вывода (printf, fprintf).  
`printf("Hello, I'm %d y.o.\n", 19);`  

### 6. Логические выражения. Операторы отношения и логические операторы. Примеры.  
- if-else конструкции, тернарный оператор (удобен при кратком условии и необходимости присваивания). Пример тернарного оператора:  
`min = (min>cnt) ? cnt : min;`
- Операторы отношения: ==, !=, <, >, <=, >=.  
- Логические операторы: !, &&, ||.  

### 7. Управляющие конструкции: циклы. Виды циклов. Бесконечный цикл. Вложенные циклы. Примеры  
- Цикл for: удобен для случаев, когда нужен счетчик. Через ; внутри круглых скобок инициализируется переменная, пишется условие и какое-то выражение, чтобы цикл продолжался.  
`for (size_t i=0; i<10; i++);`  
- Цикл while-do - цикл с предусловием: указывается условие в круглых скобах и все, а изменение, например, переменной, указывается внутри цикла.  
`while ((ch=getchar())!='\n');`
- Цикл do-while - цикл с постусловием: такой же, как и предыдущий, но первая итерация выполняется 100%, а после уже проверяется условие.  
`do code=scanf("%d", &num) while (code!=1);`  
- Бесконечный цикл - возникает при неправильной постановки условий выхода из цикла. Означает, что итерации будут выполнятся бесконечно и никогда не закончатся, т.к. условие всегда будет истинно.  
`while (1);`  
- Вложенные циклы - циклы внутри циклов. Степень вложенности может быть любой. Пусть m1, m2, m3, .. - количество итераций каждого отдельно цикла, тогда общее количество итераций всего цикла будет равно П(m).  

### 8. Управляющие конструкции: ветвления и переходы. Тернарный оператор. Конструкция switch-case. Примеры  
- Ветвления и тернарный оператор были раскрыты в **6**.  
- Переходы: break (немедленный выход из цикла), continue (пропуск итерации, переход к следующей), return (выход из функции и возврат значения), goto (переход к метке, не рекомендуется).  
- switch-case работает только с целочисленными типами данных. После каждого кейса нужно вручную выходить из switch, иначе будет выполнен следующий кейс.  
```
switch (choice) {
    case 1: 
    case 2: 
        printf("Bad\n");
        break;
    case 3:
        printf("Ok\n");
        break;
    case 4:
        printf("Good\n");
        break;
    case 5:
        printf("Nice\n");
        break;
    default:
        printf("No info\n");
}
```  
### 9. Буферизированный и не буферизированный ввод вывод. Файловый ввод/вывод в поток. Смысл обнаружения конца файла. Обработка потока символов. Примеры.  
- Буферизированный ввод/вывод - сначала временная запись в память ввода/вывода, после чего обработка данных. Буфер имеет конкретный размер, различающийся от системы к системе. Стандартный размер буфера (для ввода/вывода) 4KiB. Интересно, что в отличие от Windows и MacOS, в Linux можно менять размер всех буферов, включая буфер ввода/вывода, в то время как в двух предыдущих системах возможность изменения размера буферов полностью отсутствует. Функции printf, scanf, puts, gets, ...
- Строчно-буферизированный - буферизация построчно, встречается в терминале (после нажатия на <Enter> заканчивается запись буфера).  
- Небуферизированный - моментальное чтение/запись и обработка. Используется в создании игр, текстового редактора, макросов на клавиши клавиатуры/мыши и много где еще.  
- Файловый ввод/вывод в поток в системах типа Unix можно произвести с помощью операторов < (ввод) и > (вывод) либо же использовать функции fputs, fgets, fprintf, ... для ввода/вывода в потоки stdin, stdout или stderr.  
`$ main < in > out` - демонстрирует работу потоков в Linux и подобных.  
`fputs("Hello, world!", stdout)` - печатает литерал-строку в поток вывода (stdout).  
- Обнаружение конца файла происходит с помощью специального символа EOF (End-of-file - константа, равная -1). В ОС Linux его можно ввести с помощью комбинации клавиш ctrl+D, а в Windows и MacOS - ctrl+Z. Т.к. в Unix-системах "все есть файл", неправильное обнаружение конца файла может привести к выходу за границы памяти и различным нежелательным последствиям. Интересно, что в unix был специальный символ конца файла EOF, что перекочевало в Си и в Linux (MacOS). Несмотря на то, что механизм определения конца файла изменился (теперь это делается по размеру файла, а не по символу конца файла), правильное обнаружение конца файла остается фундаментальным умением, а понимание - ключевым понятием в работе и понимании систем Unix.  

### 10. Функции. Параметры и аргументы функции. Возврат значения из функции. Объявление и определение функции. Примеры.  
- Функция - это именованный самодостаточный блок кода, выполняющий конкретную задачу, может принимать аргументы и возвращать значения. Функция **main** является точкой входа в Си (т.е. скомпилированный код на Си запускается с main, даже если выше или ниже есть еще другие функции).  
- Параметры функции - переменные, объявленные в определении функции, под которые локально выделяется память (размер зависит от типа данных).  
- Аргументы - фактические значения, которые передаются в функцию и присваиваются соответствующим параметрам.  
- Возврат значения функции происходит с помощью специального слова return. Функция может возвращать либо ничего (void), либо любой другой **один** тип данных, т.е. нельзя вернуть больше 1 значения. Интересно, что структуры можно возвращать и принимать в отличие от тех же массивов (только указатели на них).  
- Объявление (прототип) функции - задание типа возвращаемого значения, имени функции и типов данных параметров. При этом задание имени параметра совершенно не обязательно.  
`double pow(double, size_t);`  
- Определение функции - представляет собой тело функции, где описывается ее работа.
```
double pow(double a, size_t n) {
    if (n==0) return 1;
    for (size_t i=2; i<n; i++) a *= a;
    return a;
}
```  
- Определение может являться одновременно и прототипом функции в том случае, если прототип функции не был написан ранее. Но в таком случае функция должна быть определена **выше** того места, где она будет сиспользоваться.  

### 11. Массивы в языке Си. Многомерные массивы. Массивы и указатели. Массивы и функции. Примеры.
- Массив в Си - хранит фиксированное количество элементов одного типа, расположенных рядом в памяти. Имя массива является указателем на первый элемент.  
`int A[10] = {0};`  
- Многомерные массивы - фактически указатель на указатели. Так же, как и обычный массив, хранит фиксированное количество элементов, расположенных рядом в памяти (каждый подмассив массива расположен рядом друг с другом). Имя массива так же является указателем на первый элемент (первый элемент первого по счету массива).  
`int A[10][10] = {{0, 5, 0}, {1, 0}, {0, 0, 3, 1}};`  
- Для получения значения первого элемента первого массива в многомерном массиве нужно разыменовать многомерный массив, получив указатель на подмассив, после чего разыменовать этот указатель, чтобы получить значение элемента подмассива.  
`*(*(A+2)+3)` - такая запись для массива, инициализированного выше будет равна 1.  
- В фукнцию нельзя передать сам массив, но можно передать указатель на него.  

### 12. Указатели. Адресная арифметика. Практическое использование указателей. Примеры.  
- Указатели - хранят адрес в памяти.  
`int *ptr = &num`  
- Адресная арифметика была показана в 11 теме в конце. {pointer} + {index} - указатель на элемент следующий через количество байт равных {index}*{sizeof {type}}. Стоит быть аккуратным, т.к. при неправильном использовании указателей можно легко выйти за пределы памяти, из-за чего программа может повести себя непредсказуемо.  
- Указатели удобно использовать с массивами, структурами и для экономии памяти (оптимизации).  

### 13. Структуры. Массивы структур. Вложенные структуры. Указатели на структуры. Выравнивание в структурах. Примеры.  
- Структуры - пользовательский тип данных, состоящий из полей с разными типами данных (каких угодно, даже структур). Для взятия элемента из структуры нужно использовать оператор `.`, например, `strct.name`. Если требуется взять элемент из указателя на структуру, можно использовать оператор `->`, например, `strct_ptr->name`, что эквивалентно `*(strct_ptr).name`  
```
struct Point {
    int x;
    int y;
};
```  
- Массивы структур - то же самое, что и обычные массивы, но вместо обычных типов данных структуры. Название массива является указателем на структуру.  
`struct Point points[10];`  
- Вложенные структуры - структуры, внутри которых лежат структуры.  
```
struct Address {
    char country[25];
    char street[50];
    int number;
};

struct Person {
    char name[50];
    struct Address address;
}
```  
- Выравнивание в структурах. Для элементов размером 1 байт нет выравнивания, для элементов размером 2 байтов, выравнивание до четного значения (размера), для 4 байтов - кратное 4. Для структуры  
```
struct Foo
{
    char ch;
    short id;
    short opt;
    int value;
};
```  
в памяти побайтово будет примерно вот так выглядеть:  
1. ch(1)
2. пусто  
3. id(1)  
4. id(2)  
5. opt(1)  
6. opt(2)  
7. пусто  
8. пусто  
9. value(1)  
10. value(2)  
11. value(3)  
12. value(4)  
